<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Panales — profundidad mejorada</title>
    <style>
      :root {
  --hex-size: 120px; /* base width */
        --gap-x: 6px;
        --gap-y: 6px;

  /* per-layer adjustments (you can fine-tune) */
        /* --layer0-translate: 0px;*/
        --layer0-translate: 0px;
        --layer0-scale: 1;
        --layer0-shadow-y: 4px;
        --layer0-shadow-blur: 8px;
        --layer0-shadow-opacity: 0.18;

        --layer1-translate: -4px;
        --layer1-scale: 1.02;
        --layer1-shadow-x: 5px;
        --layer1-shadow-y: 15px;
        --layer1-shadow-blur: 5px;
        --layer1-shadow-opacity: 0.8;

        --layer2-translate: -6px;
        --layer2-scale: 1.04;
        --layer1-shadow-x: 5px;
        --layer1-shadow-y: 10px;
        --layer2-shadow-blur: 5px;
        --layer2-shadow-opacity: 0.9;
      }

      html,
      body {
        margin: 0;
        min-height: 100vh;
        font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        display: flex;
        align-items: center;
        justify-content: center;
        background: url("image.png");
        background-color: #e9f6ff;
        color: #0b3b66;
        background-size: cover;
        background-repeat: no-repeat;
        background-position: center;
        background-attachment: fixed;
      }

      .wrapper {
        width: 100%;
        max-width: 1300px;
        padding: 18px;
        box-sizing: border-box;
      }

      h2 {
        margin: 0 0 6px 0;
        text-align: center;
        color: #0b3b66;
      }
      p.help {
        text-align: center;
        color: #205e85;
        margin: 8px 0 18px 0;
      }

  /* relative container for absolute-positioned columns */
      .board {
        position: relative;
        width: 100%;
        margin: 0 auto;
        box-sizing: border-box;
        overflow: visible;
      }

  /* column positioned by JS */
      .column {
        position: absolute;
        display: flex;
        flex-direction: column;
        gap: var(--gap-y);
        width: var(--hex-size);
        pointer-events: none; /* anchors seguirán recibiendo eventos */
      }

  /* anchor that contains SVG (captures pointer-events) */
      .hex-link {
        pointer-events: auto;
        display: inline-block;
        width: var(--hex-size);
        height: calc(var(--hex-size) * 0.8660254); /* H = W * sqrt(3)/2 */
        transform-origin: 50% 50%;
        transition: transform 220ms cubic-bezier(0.2, 0.9, 0.2, 1), filter 220ms;
        border-radius: 8px;
        text-decoration: none;
        color: inherit;
        -webkit-tap-highlight-color: transparent;
      }

  /* styles applied per layer (controlled by JS adding class layer-N) */
      .layer-0 {
        transform: translateY(var(--layer0-translate)) scale(var(--layer0-scale));
        z-index: 10;
      }
      .layer-1 {
        transform: translateY(var(--layer1-translate)) scale(var(--layer1-scale));
        z-index: 20;
        filter: drop-shadow(var(--layer1-shadow-x) var(--layer1-shadow-y) var(--layer1-shadow-blur) rgba(12, 20, 30, var(--layer1-shadow-opacity)));
      }
      .layer-2 {
        transform: translateY(var(--layer2-translate)) scale(var(--layer2-scale));
        z-index: 30;
        filter: drop-shadow(var(--layer1-shadow-x) var(--layer1-shadow-y) var(--layer2-shadow-blur) rgba(12, 20, 30, var(--layer2-shadow-opacity)));
      }

  /* hover: extra lift (subtracts 6px from current translateY) and slight scale */
      .hex-link:hover.layer-0 {
        transform: translateY(calc(var(--layer0-translate) - 6px)) scale(calc(var(--layer0-scale) * 1.03));
      }
      .hex-link:hover.layer-1 {
        transform: translateY(calc(var(--layer1-translate) - 6px)) scale(calc(var(--layer1-scale) * 1.03));
      }
      .hex-link:hover.layer-2 {
        transform: translateY(calc(var(--layer2-translate) - 6px)) scale(calc(var(--layer2-scale) * 1.035));
      }

  /* SVG adjustments */
      .hex-svg {
        width: 100%;
        height: 100%;
        display: block;
      }

  /* class for the SVG text: fallback sizing + visual */
      .hex-text {
        font-weight: 700;
        /* fallback responsive size using css clamp (applies in browsers that use CSS for SVG text) */
        font-size: clamp(8px, calc(var(--hex-size) * 0.085), 16px);
        fill: white;
        pointer-events: none;
        font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      }

  /* responsive */
      @media (max-width: 900px) {
        :root {
          --hex-size: 92px;
          --layer1-translate: -9px;
          --layer2-translate: -18px;
        }
      }
      @media (max-width: 520px) {
        :root {
          --hex-size: 72px;
          --gap-y: 6px;
          --layer1-translate: -8px;
          --layer2-translate: -14px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <div id="board" class="board" role="grid" aria-label="Panales"></div>
    </div>

    <script>
      const data = [
        { color: "#06b6d4", title: "Bill of Landing & Passing", href: "https://youtu.be/W-SpP-Z0Uu8?si=FwsnCoLB6CbOpMMY", col: 0, layer: 0 },
        { color: "#06b6d4", title: "Purchases", href: "#erp", col: 0, layer: 0 },
        { color: "#06b6d4", title: "Online Vendor and Csutomer Portal", href: "#fin", col: 0, layer: 0 },
        { color: "#0e7490", title: "Just in Time Ordering", href: "#log", col: 0, layer: 1 },

        { color: "#023467", title: "OMS", href: "#crm", col: 1, layer: 2 },
        { color: "#06b6d4", title: "Sales", href: "#sales", col: 1, layer: 0 },
        { color: "#06b6d4", title: "Carrier Confimation", href: "#inv", col: 1, layer: 0 },

        { color: "#06b6d4", title: "Invoicing and Payments", href: "#price", col: 2, layer: 0 },
        { color: "#06b6d4", title: "Inventory Management", href: "#orders", col: 2, layer: 0 },
        { color: "#06b6d4", title: "Pallet Tags", href: "#qa", col: 2, layer: 0 },
        { color: "#0e7490", title: "Margin Analysis", href: "#bank", col: 2, layer: 1 },

        { color: "#0e7490", title: "Liquidations", href: "#mkt", col: 3, layer: 1 },
        { color: "#06b6d4", title: "Pricelists", href: "#pallets", col: 3, layer: 0 },
        { color: "#06b6d4", title: "Lot Tracking", href: "#pos", col: 3, layer: 0 },

        { color: "#045fa3", title: "Email Marketing", href: "#mobile", col: 4, layer: 0 },
        { color: "#045fa3", title: "GTN and PTI", href: "#packing", col: 4, layer: 0 },
        { color: "#045fa3", title: "Comition Plans and Payouts", href: "#routes", col: 4, layer: 1 },
        { color: "#045fa3", title: "Barcoding", href: "#pricing", col: 4, layer: 0 },

        { color: "#045fa3", title: "Packing and Processing", href: "#acc", col: 5, layer: 1 },
        { color: "#023467", title: "ERP", href: "#inv", col: 5, layer: 2 },
        { color: "#045fa3", title: "Accounting", href: "#inv2", col: 5, layer: 0 },
        { color: "#045fa3", title: "eSignature", href: "#payroll", col: 5, layer: 0 },

        { color: "#045fa3", title: "Routes and Dispatch", href: "#payroll", col: 6, layer: 0 },
        { color: "#045fa3", title: "Warehouse Management", href: "#payroll", col: 6, layer: 0 },
        { color: "#045fa3", title: "Bank Feed", href: "#payroll", col: 6, layer: 0 },
        { color: "#045fa3", title: "Expense Management", href: "#payroll", col: 6, layer: 0 },

        { color: "#057cc1", title: "USDA Market Prices", href: "#payroll", col: 7, layer: 1 },
        { color: "#057cc1", title: "Price Exchange", href: "#payroll", col: 7, layer: 0 },
        { color: "#057cc1", title: "Point of Sale", href: "#payroll", col: 7, layer: 0 },

        { color: "#057cc1", title: "Online Ordering", href: "#payroll", col: 8, layer: 0 },
        { color: "#057cc1", title: "Grower Accounting", href: "#payroll", col: 8, layer: 0 },
        { color: "#057cc1", title: "CRM", href: "#payroll", col: 8, layer: 1 },

        { color: "#057cc1", title: "Grower Inventory", href: "#payroll", col: 9, layer: 1 },
        { color: "#057cc1", title: "Pallet Handing", href: "#payroll", col: 9, layer: 0 },
        { color: "#057cc1", title: "Harvest Management", href: "#payroll", col: 9, layer: 0 },

        { color: "#057cc1", title: "Mobile Apps", href: "#payroll", col: 10, layer: 0 },
        { color: "#057cc1", title: "Load Planning", href: "#payroll", col: 10, layer: 0 },
        { color: "#057cc1", title: "Quality Assurance", href: "#payroll", col: 10, layer: 1 },

        { color: "#023467", title: "Financing", href: "#payroll", col: 11, layer: 1 },
        { color: "#023467", title: "Banking", href: "#payroll", col: 11, layer: 0 },
        { color: "#023467", title: "Treasury Liquidity", href: "#payroll", col: 11, layer: 0 },

        { color: "#023467", title: "Logistics", href: "#payroll", col: 12, layer: 0 },
        { color: "#023467", title: "ACH and Credit Cards Payments", href: "#payroll", col: 12, layer: 0 },
        { color: "#023467", title: "International Payments (FOREX)", href: "#payroll", col: 12, layer: 1 },
      ];

      const columns = 13;
      const columnStartOffsets = [55, 110, 55, 110, 55, 0, 55, 110, 55, 110, 55, 110, 55];

      /* -----------------------------
        Geometry helpers
      ------------------------------ */
      function getCssPx(varName, fallback = 0) {
        const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        if (!v) return fallback;
        return Number(v.replace("px", "").trim()) || fallback;
      }

      const board = document.getElementById("board");
      board.innerHTML = "";

      const hexW = getCssPx("--hex-size", 120);
      const hexH = (hexW * Math.sqrt(3)) / 2;
      const gapX = getCssPx("--gap-x", 0);
      const gapY = getCssPx("--gap-y", 8);

      /* paso horizontal ideal para flat-top hex: 0.75 * ancho */
      const stepX = hexW * 0.75 + gapX;

      /* distribuir por columna según item.col (fallback round-robin) */
      const cols = Array.from({ length: columns }, () => []);
      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        const validCol = Number.isInteger(item.col) && item.col >= 0 && item.col < columns;
        if (validCol) cols[item.col].push(item);
        else cols[i % columns].push(item);
      }

      /* ajustar tamaño del contenedor para que no corte nada */
      const maxColLen = Math.max(...cols.map((c) => c.length));
      const maxOffset = Math.max(...columnStartOffsets, 0);
      const boardWidth = Math.ceil(stepX * (columns - 1) + hexW + 40);
      const boardHeight = Math.ceil(maxOffset + maxColLen * (hexH + gapY) + 80);
      board.style.width = boardWidth + "px";
      board.style.height = boardHeight + "px";

      /* polygon points para el hex (flat-top) */
      const hexPoints = "25,0 75,0 100,43.301 75,86.602 25,86.602 0,43.301";

      /* SVG defs: gradient + subtle internal highlight + soft filter */
      const svgDefs = `
        <defs>
          <linearGradient id="gTop" x1="0" x2="0" y1="0" y2="1">
            <stop offset="0%" stop-color="rgba(255,255,255,0.18)"/>
            <stop offset="18%" stop-color="rgba(255,255,255,0.08)"/>
            <stop offset="100%" stop-color="rgba(0,0,0,0.06)"/>
          </linearGradient>

          <!-- subtle inner top rim for glossy effect -->
          <linearGradient id="gRim" x1="0" x2="0" y1="0" y2="1">
            <stop offset="0%" stop-color="rgba(255,255,255,0.28)"/>
            <stop offset="40%" stop-color="rgba(255,255,255,0.06)"/>
            <stop offset="100%" stop-color="rgba(255,255,255,0)"/>
          </linearGradient>

          <!-- soft multi-layer shadow filter (used as fallback for browsers honoring SVG filters) -->
          <filter id="softDrop" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur in="SourceAlpha" stdDeviation="6" result="blur"/>
            <feOffset in="blur" dx="0" dy="8" result="offsetBlur"/>
            <feComponentTransfer>
              <feFuncA type="linear" slope="0.22"/>
            </feComponentTransfer>
            <feMerge>
              <feMergeNode in="offsetBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>`;

      /* helper: escapar texto para insertar en title (aunque ya limpiamos con escapeHtml) */
      function escapeHtml(s) {
        return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }

      /* --- función avanzada para crear texto SVG adaptativo --- */
      function appendAdaptiveText(svgEl, textStr) {
        const SVG_NS = "http://www.w3.org/2000/svg";
        const maxWidth = 78; // user units inside viewBox (100 wide) -> deja márgenes laterales
        let fontSize = 9; // inicial (user units)
        const minFontSize = 5;

        // Clase que aplica fill/family/weight; font-size lo controlamos por atributo (user units)
        // Creamos un texto temporal para medir
        //Estos determinan el centrado
        const tmp = document.createElementNS(SVG_NS, "text");
        tmp.setAttribute("x", "50");
        tmp.setAttribute("text-anchor", "middle");
        tmp.setAttribute("dominant-baseline", "middle");

        tmp.setAttribute("class", "hex-text");
        tmp.setAttribute("font-size", fontSize);
        tmp.textContent = textStr;
        svgEl.appendChild(tmp);

        // medir y reducir si hace falta
        let len = tmp.getComputedTextLength();
        while (len > maxWidth && fontSize > minFontSize) {
          fontSize -= 0.5;
          tmp.setAttribute("font-size", fontSize);
          len = tmp.getComputedTextLength();
        }

        // quitamos tmp (iremos a crear el grupo final)
        svgEl.removeChild(tmp);

        // envuelve en <g> para luego centrar todo el bloque como unidad
        const g = document.createElementNS(SVG_NS, "g");

        // intentamos single line — si cabe, lo ponemos en un tspan simple
        const single = document.createElementNS(SVG_NS, "text");
        single.setAttribute("x", "50");
        single.setAttribute("text-anchor", "middle");
        single.setAttribute("class", "hex-text");
        single.setAttribute("font-size", fontSize);
        single.textContent = textStr;

        // medir single line
        svgEl.appendChild(single);
        const singleLen = single.getComputedTextLength();
        svgEl.removeChild(single);

        if (singleLen <= maxWidth) {
          // cabe en una línea: insertamos text dentro del grupo con una tspan y lo centraremos por getBBox
          const textEl = document.createElementNS(SVG_NS, "text");
          textEl.setAttribute("x", "50");
          textEl.setAttribute("text-anchor", "middle");
          textEl.setAttribute("class", "hex-text");
          textEl.setAttribute("font-size", fontSize);

          const tspan = document.createElementNS(SVG_NS, "tspan");
          tspan.setAttribute("x", "50");
          // colocamos una y provisional; el grupo se centrará tras medir
          tspan.setAttribute("y", String((43.301).toFixed(2)));
          tspan.textContent = textStr;
          textEl.appendChild(tspan);
          g.appendChild(textEl);
          svgEl.appendChild(g);
        } else {
          // no cabe: wrapping greedy por palabras
          const words = textStr.split(/\s+/);
          const lines = [];
          let line = "";

          // tester para medir candidatos (con fontSize ya reducido)
          const tester = document.createElementNS(SVG_NS, "text");
          tester.setAttribute("x", "50");
          tester.setAttribute("text-anchor", "middle");
          tester.setAttribute("class", "hex-text");
          tester.setAttribute("font-size", fontSize);
          svgEl.appendChild(tester);

          for (let w of words) {
            const candidate = line ? line + " " + w : w;
            tester.textContent = candidate;
            if (tester.getComputedTextLength() <= maxWidth) {
              line = candidate;
            } else {
              if (line) lines.push(line);
              line = w;
            }
          }
          if (line) lines.push(line);
          svgEl.removeChild(tester);

          // si demasiadas líneas, intentar reducir un poco más la fuente y recomponer
          if (lines.length > 3) {
            let attempts = 0;
            while (lines.length > 3 && fontSize > minFontSize && attempts < 6) {
              fontSize -= 0.5;
              // rewrap with smaller fontSize
              const tester2 = document.createElementNS(SVG_NS, "text");
              tester2.setAttribute("x", "50");
              tester2.setAttribute("text-anchor", "middle");
              tester2.setAttribute("class", "hex-text");
              tester2.setAttribute("font-size", fontSize);
              svgEl.appendChild(tester2);

              const newLines = [];
              let l = "";
              for (let w of words) {
                const candidate = l ? l + " " + w : w;
                tester2.textContent = candidate;
                if (tester2.getComputedTextLength() <= maxWidth) {
                  l = candidate;
                } else {
                  if (l) newLines.push(l);
                  l = w;
                }
              }
              if (l) newLines.push(l);
              svgEl.removeChild(tester2);

              if (newLines.length <= 3) {
                lines.splice(0, lines.length, ...newLines);
                break;
              } else {
                lines.splice(0, lines.length, ...newLines);
              }
              attempts++;
            }
          }

          // crear elemento final con tspans dentro de un <text> y añadirlo al grupo
          const finalText = document.createElementNS(SVG_NS, "text");
          finalText.setAttribute("x", "50");
          finalText.setAttribute("text-anchor", "middle");
          finalText.setAttribute("class", "hex-text");
          finalText.setAttribute("font-size", fontSize);

          // provisional startY (será ajustado centrando el grupo)
          const lineHeight = 1.05 * fontSize;
          const totalHeight = lines.length * lineHeight;
          const centerY = 43.301; // centro geométrico del viewBox 0..86.602
          const provisionalStartY = centerY - totalHeight / 2 + lineHeight / 2;
          finalText.setAttribute("y", String(provisionalStartY.toFixed(2)));

          lines.forEach((ln, idx) => {
            const tspan = document.createElementNS(SVG_NS, "tspan");
            tspan.setAttribute("x", "50");
            if (idx === 0) {
              // usamos la 'y' del padre
            } else {
              tspan.setAttribute("dy", "1.05em");
            }
            tspan.textContent = ln;
            finalText.appendChild(tspan);
          });

          g.appendChild(finalText);
          svgEl.appendChild(g);
        }

        // --- centrar el grupo (g) perfectamente dentro del viewBox usando getBBox() ---
        const doCenterGroup = () => {
          try {
            const vb = svgEl.viewBox.baseVal;
            const centerX = vb.width / 2;
            const centerY = vb.height / 2;
            const bbox = g.getBBox();
            const bboxCenterX = bbox.x + bbox.width / 2;
            const bboxCenterY = bbox.y + bbox.height / 2;
            const dx = centerX - bboxCenterX;
            const dy = centerY - bboxCenterY;
            g.setAttribute("transform", `translate(${dx.toFixed(2)}, ${dy.toFixed(2)})`);
          } catch (err) {
            // si getBBox falla por alguna razón, dejamos el texto tal cual
            console.warn("Centrado de grupo falló:", err);
          }
        };

        if (document.fonts) {
          document.fonts.ready.then(() => requestAnimationFrame(doCenterGroup));
        } else {
          requestAnimationFrame(doCenterGroup);
        }
      }

      /* Construir columnas */
      cols.forEach((colItems, colIndex) => {
        const col = document.createElement("div");
        col.className = "column";
        const left = Math.round(colIndex * stepX);
        const top = Math.round(columnStartOffsets[colIndex] || 0);
        col.style.left = left + "px";
        col.style.top = top + "px";
        col.style.width = hexW + "px";

        colItems.forEach((item) => {
          const a = document.createElement("a");
          a.className = "hex-link";

          // layer default 0
          const layer = Number.isInteger(item.layer) && item.layer >= 0 && item.layer <= 2 ? item.layer : 0;
          a.classList.add(`layer-${layer}`);
          a.href = item.href || "#";
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.setAttribute("aria-label", item.title || "casilla");

          const cleanTitle = escapeHtml(item.title);
          const baseColor = escapeHtml(item.color || "#2b6cb0");

          // crear el SVG sin el <text> (lo añadiremos con appendAdaptiveText)
          a.innerHTML = `
            <svg class="hex-svg" viewBox="0 0 100 86.602" role="img" aria-hidden="false" focusable="false">
              ${svgDefs}
              <!-- base polygon -->
              <polygon points="${hexPoints}" fill="${baseColor}" stroke="rgba(0,0,0,0.07)" stroke-width="0.9"></polygon>
              <!-- glossy overlay -->
              <polygon points="${hexPoints}" fill="url(#gTop)" style="mix-blend-mode: overlay; opacity:0.7"></polygon>
              <!-- rim light -->
              <polygon points="${hexPoints}" fill="url(#gRim)" style="mix-blend-mode: screen; opacity:0.55"></polygon>
              <!-- subtle inner darker base to add depth -->
              <polygon points="${hexPoints}" fill="rgba(0,0,0,0.06)"></polygon>
              <!-- accessibility title -->
              <title>${cleanTitle}</title>
            </svg>
          `;

          col.appendChild(a);
        });

        board.appendChild(col);
      });

      // después de renderizar el DOM, recorremos cada svg y añadimos el texto adaptativo
      // small timeout to ensure layout is stable (but immediate is usually fine)
      requestAnimationFrame(() => {
        document.querySelectorAll(".hex-svg").forEach((svgEl, idx) => {
          const parentAnchor = svgEl.closest(".hex-link");
          if (!parentAnchor) return;
          const aria = parentAnchor.getAttribute("aria-label") || parentAnchor.querySelector("title")?.textContent || "";
          const txt = aria;
          appendAdaptiveText(svgEl, txt);
        });
      });

      /* Si cambias CSS variables por media queries, recarga para recalcular posiciones */
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          location.reload();
        }, 200);
      });
    </script>
  </body>
</html>
